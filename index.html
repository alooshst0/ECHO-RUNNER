<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>ECHO RUNNER ‚Äî Shadows of the Grid</title>
<meta name="description" content="ECHO RUNNER ‚Äî ŸÑÿπÿ®ÿ© ŸÖÿ™ÿµŸÅÿ≠ ŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸäÿ©ÿå Neumorphic UIÿå Canvasÿå Vanilla JS" />
<style>
/* ===========================
   ECHO RUNNER ‚Äî Optimized
   CSS: Neumorphism + Cyber Neon
   Mobile First Approach
   =========================== */

/* RESET & BASE */
* { 
    box-sizing: border-box; 
    -webkit-tap-highlight-color: transparent; 
    margin: 0; 
    padding: 0;
}

html, body { 
    height: 100%; 
    margin: 0; 
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; 
    background: #0b0b0d; 
    color: #e6eef8; 
    -webkit-font-smoothing: antialiased; 
    -moz-osx-font-smoothing: grayscale; 
    overflow: hidden;
}

:root {
    --bg: #0b0b0d;
    --surface: #0f1318;
    --muted: #9aa7b2;
    --accent1: #00fff0;
    --accent2: #ff4dd2;
    --accent3: #ffb24d;
    --glass: rgba(255,255,255,0.03);
    --radius: 14px;
    --neu-dark: rgba(0,0,0,0.6);
    --neu-light: rgba(255,255,255,0.03);
    --shadow-1: 10px 10px 20px rgba(0,0,0,0.7), -6px -6px 18px rgba(255,255,255,0.02);
    --glass-border: rgba(255,255,255,0.04);
    --transition: 220ms cubic-bezier(.2,.9,.2,1);
}

/* LAYOUT - MOBILE FIRST */
.app {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 12px;
    min-height: 100vh;
    background: linear-gradient(180deg, #080808 0%, #0e0f12 60%);
}

.panel {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 12px;
    flex: 1;
}

/* Game canvas container */
.game-wrap {
    position: relative;
    flex: 1;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.15));
    border-radius: 16px;
    padding: 12px;
    box-shadow: var(--shadow-1);
    border: 1px solid rgba(255,255,255,0.02);
    overflow: hidden;
    min-height: 60vh;
}

/* Canvas responsive */
#gameCanvas {
    width: 100%;
    height: 100%;
    display: block;
    border-radius: 12px;
    background: radial-gradient(1200px 400px at 10% 10%, rgba(0,255,240,0.04), transparent 5%),
                linear-gradient(180deg, #071018 0%, #081018 40%, #071018 100%);
    box-shadow: inset 0 0 120px rgba(0,255,240,0.02), inset 0 0 60px rgba(255,77,210,0.01);
}

/* Right panel (UI) - Hidden on mobile by default */
.sidebar {
    display: none;
    width: 100%;
    max-height: 35vh;
    overflow: auto;
    padding: 12px;
    gap: 10px;
    background: linear-gradient(180deg, rgba(255,255,255,0.012), rgba(0,0,0,0.16));
    border-radius: 14px;
    box-shadow: var(--shadow-1);
    border: 1px solid rgba(255,255,255,0.02);
}

/* Reusable neumorphic card */
.card {
    background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(0,0,0,0.12));
    border-radius: var(--radius);
    padding: 12px;
    box-shadow: 8px 8px 16px rgba(0,0,0,0.65), -6px -6px 16px rgba(255,255,255,0.02);
    border: 1px solid var(--glass-border);
    transition: box-shadow var(--transition), transform var(--transition);
}

/* HEADS */
.h1 { 
    font-size: 16px; 
    font-weight: 700; 
    letter-spacing: 0.2px; 
    color: #e6f9ff; 
    margin: 0 0 6px 0; 
    display: flex; 
    align-items: center; 
    gap: 8px; 
}

.h2 { 
    font-size: 12px; 
    color: var(--muted); 
    margin: 0; 
}

/* HUD overlay */
.hud {
    position: absolute;
    left: 12px;
    top: 12px;
    z-index: 30;
    display: flex;
    gap: 8px;
    align-items: center;
    pointer-events: auto;
}

.hud .stat {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12));
    padding: 6px 10px;
    border-radius: 10px;
    display: flex;
    gap: 6px;
    align-items: center;
    box-shadow: 6px 6px 12px rgba(0,0,0,0.6), -4px -4px 10px rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.02);
    font-size: 12px;
    min-width: 60px;
    justify-content: center;
}

/* RIGHT HUD */
.hud-right {
    position: absolute;
    right: 12px;
    top: 12px;
    display: flex;
    gap: 8px;
    align-items: center;
    z-index: 30;
}

/* Mobile Controls */
.controls-touch {
    position: absolute;
    left: 12px;
    bottom: 12px;
    display: flex;
    gap: 8px;
    z-index: 30;
}

.touch-btn {
    width: 56px;
    height: 56px;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(180deg, rgba(255,255,255,0.012), rgba(0,0,0,0.14));
    box-shadow: 8px 8px 16px rgba(0,0,0,0.6), -6px -6px 12px rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.02);
    font-weight: 700;
    font-size: 16px;
    color: #cfeff3;
    user-select: none;
    touch-action: manipulation;
    transition: all 0.1s ease;
}

.touch-btn:active {
    transform: scale(0.95);
    box-shadow: inset 2px 2px 4px rgba(0,0,0,0.6), inset -2px -2px 4px rgba(255,255,255,0.02);
}

/* Center controls */
.center-controls {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: 12px;
    display: flex;
    gap: 8px;
    z-index: 30;
}

/* Ability cooldown */
.ability {
    width: 50px;
    height: 50px;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.12));
    border: 1px solid rgba(255,255,255,0.02);
    position: relative;
    overflow: hidden;
    font-size: 18px;
}

.ability .cd {
    position: absolute;
    inset: 0;
    background: rgba(2,2,2,0.55);
    transform-origin: center bottom;
    transform: scaleY(0);
    transition: transform 200ms linear;
}

/* Buttons */
.btn {
    padding: 8px 12px;
    border-radius: 12px;
    display: inline-flex;
    gap: 6px;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.16));
    border: 1px solid rgba(255,255,255,0.03);
    color: #e6f9ff;
    font-weight: 600;
    font-size: 12px;
    transition: all var(--transition);
    box-shadow: 6px 6px 12px rgba(0,0,0,0.6), -4px -4px 10px rgba(255,255,255,0.02);
    touch-action: manipulation;
}

.btn:active {
    transform: translateY(2px);
}

/* Modal */
.modal {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    pointer-events: none;
    padding: 12px;
    background: rgba(0,0,0,0.8);
}

.modal .dialog {
    pointer-events: auto;
    width: min(400px, 100%);
    max-height: 90vh;
    overflow: auto;
    background: linear-gradient(180deg, rgba(255,255,255,0.018), rgba(0,0,0,0.2));
    border-radius: 16px;
    padding: 16px;
    border: 1px solid rgba(255,255,255,0.03);
    box-shadow: 0 20px 60px rgba(0,0,0,0.8);
}

/* Small text */
.muted { 
    color: var(--muted); 
    font-size: 12px; 
}

/* Mobile Menu Button */
.mobile-menu-btn {
    position: fixed;
    top: 12px;
    right: 12px;
    z-index: 1001;
    width: 44px;
    height: 44px;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.16));
    border: 1px solid rgba(255,255,255,0.03);
    color: #e6f9ff;
    font-size: 18px;
    box-shadow: 6px 6px 12px rgba(0,0,0,0.6), -4px -4px 10px rgba(255,255,255,0.02);
}

/* Responsive Design */
@media (min-width: 768px) {
    .app {
        flex-direction: row;
        padding: 16px;
        gap: 16px;
    }
    
    .panel {
        flex-direction: row;
        gap: 16px;
    }
    
    .sidebar {
        display: flex;
        flex-direction: column;
        width: 300px;
        max-height: calc(100vh - 32px);
    }
    
    .mobile-menu-btn {
        display: none;
    }
    
    .hud {
        left: 20px;
        top: 18px;
    }
    
    .hud-right {
        right: 20px;
        top: 18px;
    }
    
    .controls-touch {
        left: 20px;
        bottom: 20px;
    }
    
    .center-controls {
        bottom: 20px;
    }
}

@media (max-width: 767px) {
    .sidebar.mobile-visible {
        display: flex;
    }
    
    .game-wrap.sidebar-visible {
        display: none;
    }
}

/* Focus accessibility */
.btn:focus, .touch-btn:focus { 
    outline: 2px solid rgba(0,255,240,0.14); 
    outline-offset: 2px; 
}

/* Scrollbar styling */
::-webkit-scrollbar {
    width: 6px;
}

::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.02);
    border-radius: 3px;
}

::-webkit-scrollbar-thumb {
    background: rgba(0,255,240,0.3);
    border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(0,255,240,0.5);
}
</style>
</head>
<body>
<div class="app" role="application" aria-label="ECHO RUNNER game">
    <!-- Mobile Menu Button -->
    <button class="mobile-menu-btn" id="mobileMenuBtn" aria-label="ŸÅÿ™ÿ≠ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©">‚ò∞</button>
    
    <div class="panel">
        <!-- GAME AREA -->
        <div class="game-wrap card" id="gameWrap" aria-hidden="false">
            <div class="hud" aria-hidden="true">
                <div class="stat" id="stat-score" title="ÿßŸÑŸÜŸÇÿßÿ∑">üî∑ <span id="score">0</span></div>
                <div class="stat" id="stat-stage" title="ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ©">‚ú¶ <span id="stage">1</span></div>
            </div>

            <div class="hud-right" aria-hidden="true">
                <div class="stat" id="stat-health">‚ù§ <span id="health">3</span></div>
                <div class="stat" id="stat-best">üèÜ <span id="best">0</span></div>
            </div>

            <!-- Canvas -->
            <canvas id="gameCanvas" role="img" aria-label="ŸÑŸàÿ≠ÿ© ÿßŸÑŸÑÿπÿ®ÿ©"></canvas>

            <!-- Touch controls - Always visible on mobile -->
            <div class="controls-touch" id="touchControls" aria-hidden="false">
                <div class="touch-btn" id="btn-left" title="Ÿäÿ≥ÿßÿ±">‚óÄ</div>
                <div class="touch-btn" id="btn-jump" title="ŸÇŸÅÿ≤">‚§¥</div>
                <div class="touch-btn" id="btn-right" title="ŸäŸÖŸäŸÜ">‚ñ∂</div>
            </div>

            <div class="center-controls" aria-hidden="true">
                <div class="ability btn" id="ability-dash" title="Dash (F)">
                    ‚ö°
                    <div class="cd" id="cd-dash" aria-hidden="true"></div>
                </div>
                <div class="ability btn" id="ability-shield" title="Shield (G)">
                    ‚õ®
                    <div class="cd" id="cd-shield" aria-hidden="true"></div>
                </div>
            </div>

            <!-- Overlay menus -->
            <div id="overlayMenu" class="modal" style="display: flex;">
                <div class="dialog card" style="text-align: center;">
                    <h2 class="h1">ECHO RUNNER</h2>
                    <p class="muted">Shadows of the Grid ‚Äî Ÿáÿ±Ÿàÿ® ÿØÿßÿÆŸÑ ÿ¥ÿ®ŸÉÿ© ÿ±ŸÇŸÖŸäÿ© ŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸäÿ©</p>
                    <div style="display: flex; flex-direction: column; gap: 8px; margin: 14px 0;">
                        <button class="btn" id="startBtn">ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®ÿ©</button>
                        <button class="btn" id="continueBtn" style="display: none;">ÿßÿ≥ÿ™ŸÉŸÖÿßŸÑ</button>
                        <button class="btn" id="settingsBtn">ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™</button>
                        <button class="btn" id="leaderBtn">ÿßŸÑÿ£ŸÅÿ∂ŸÑ</button>
                    </div>
                    <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                        <button class="btn" id="exportSave">ŸÜÿ≥ÿÆ ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä</button>
                        <label for="importFile" class="btn" style="cursor: pointer;">ÿßÿ≥ÿ™ÿπÿßÿØÿ©</label>
                        <input type="file" accept="application/json" id="importFile" style="display: none;">
                    </div>
                    <p class="muted" style="margin-top: 14px; font-size: 11px;">ÿ™ÿ≠ŸÉŸÖ: ÿ£ÿ≥ŸáŸÖ / WASD ‚Äî ŸÖŸáÿßÿ±ÿßÿ™: F (Dash) - G (Shield)</p>
                </div>
            </div>

            <!-- Game Over modal -->
            <div id="gameOverModal" class="modal" style="display: none;">
                <div class="dialog card" style="text-align: center;">
                    <h2 class="h1">Game Over</h2>
                    <p class="muted">ŸÜŸÇÿßÿ∑ŸÉ: <strong id="finalScore">0</strong></p>
                    <div style="display: flex; gap: 8px; justify-content: center; margin-top: 12px;">
                        <button class="btn" id="retryBtn">ÿ•ÿπÿßÿØÿ©</button>
                        <button class="btn" id="menuBtn">ÿßŸÑŸÇÿßÿ¶ŸÖÿ©</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- SIDEBAR: Hidden on mobile by default -->
        <aside class="sidebar" id="sidebar" role="region" aria-label="ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div class="h1">ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÑÿπÿ®ÿ©</div>
                        <div class="h2">ECHO RUNNER ‚Äî Shadow Grid</div>
                    </div>
                    <div style="text-align: left;">
                        <div class="muted" style="font-size: 11px;">ŸÜÿ≥ÿÆÿ© ŸÖÿ≠ŸÖŸàŸÑÿ©</div>
                        <div class="muted" style="font-size: 11px;">ŸÖŸÑŸÅ Ÿàÿßÿ≠ÿØ</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="h1">ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ</div>
                <div class="h2 muted">ÿ£ÿ≤ÿ±ÿßÿ± ÿ≥ÿ±Ÿäÿπÿ©</div>
                <div style="display: flex; gap: 6px; margin-top: 8px; flex-wrap: wrap;">
                    <button class="btn" id="pauseBtn">ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™</button>
                    <button class="btn" id="muteBtn">ŸÉÿ™ŸÖ</button>
                    <button class="btn" id="themeBtn">ÿ´ŸäŸÖ</button>
                </div>
                <hr style="opacity: 0.06; margin: 10px 0;">
                <div class="muted">ŸÜŸÇÿßÿ∑: <strong id="sideScore">0</strong></div>
                <div class="muted">ÿ£ŸÅÿ∂ŸÑ: <strong id="sideBest">0</strong></div>
            </div>

            <div class="card" id="leaderboardCard">
                <div class="h1">ÿßŸÑÿ£ŸÅÿ∂ŸÑ</div>
                <ol id="leaderList" style="padding-left: 8px; margin-top: 8px; font-size: 12px;"></ol>
            </div>

            <div class="card">
                <div class="h1">ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™</div>
                <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 8px;">
                    <label class="muted" style="font-size: 12px;">ŸÖŸàÿ≥ŸäŸÇŸâ</label>
                    <input type="range" id="musicVol" min="0" max="1" step="0.01" value="0.4">
                    <label class="muted" style="font-size: 12px;">ŸÖÿ§ÿ´ÿ±ÿßÿ™</label>
                    <input type="range" id="sfxVol" min="0" max="1" step="0.01" value="0.9">
                    <label class="muted" style="font-size: 12px;">ÿµÿπŸàÿ®ÿ©</label>
                    <select id="difficulty" style="background: var(--surface); color: white; border: 1px solid var(--glass-border); padding: 6px; border-radius: 8px;">
                        <option value="easy">ÿ≥ŸáŸÑ</option>
                        <option value="normal" selected>ŸÖÿ™Ÿàÿ≥ÿ∑</option>
                        <option value="hard">ÿµÿπÿ®</option>
                    </select>
                    <div style="display: flex; gap: 8px; align-items: center; justify-content: space-between;">
                        <div class="muted" style="font-size: 12px;">ÿπÿ±ÿ∂ ÿßŸÑŸÑŸÖÿ≥</div>
                        <input type="checkbox" id="showTouch" checked>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="h1">ÿ™ÿπŸÑŸäŸÖÿßÿ™ ŸÇÿµŸäÿ±ÿ©</div>
                <div class="muted" style="font-size: 11px; line-height: 1.4; margin-top: 8px; text-align: right;">
                    ‚óº ÿ™ÿ¨ŸÜŸëÿ® ÿßŸÑÿπŸÇÿ®ÿßÿ™ ‚Äî ŸÑŸÉŸÑ ÿ™ÿµÿßÿØŸÖ ÿ™ŸÇŸÑŸë ÿ≠Ÿäÿßÿ© Ÿàÿßÿ≠ÿØÿ©.<br>
                    ‚óº ÿßÿ¨ŸÖÿπ Data Shards ŸÑÿ≤ŸäÿßÿØÿ© ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©.<br>
                    ‚óº Dash Ÿäÿ¨ÿπŸÑ ÿ¨ÿ≥ŸÖŸÉ ÿπÿßÿ¨ÿ≤ÿßŸã ŸÖÿ§ŸÇÿ™Ÿãÿß.<br>
                    ‚óº Shield Ÿäÿ≠ŸÖŸäŸÉ ŸÑÿ´ŸàÿßŸÜŸä ŸÇÿµŸäÿ±ÿ©.
                </div>
            </div>
        </aside>
    </div>
</div>

<script>
// =========================
// ECHO RUNNER - MOBILE OPTIMIZED
// =========================

console.log('üöÄ ECHO RUNNER - Initializing...');

/* UTILITIES & STORAGE */
const Storage = {
    keyPrefix: 'echo_runner_v2',
    save(obj) {
        try {
            localStorage.setItem(this.keyPrefix, JSON.stringify(obj));
            return true;
        } catch(e) { 
            console.warn('Save failed:', e);
            return false;
        }
    },
    load() {
        try {
            const data = localStorage.getItem(this.keyPrefix);
            return data ? JSON.parse(data) : null;
        } catch(e) { 
            console.warn('Load failed:', e);
            return null;
        }
    },
    exportJSON(name = 'echo-backup.json') {
        try {
            const data = this.load() || defaultSave();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 2000);
        } catch(e) {
            console.error('Export failed:', e);
        }
    },
    importJSON(json) {
        try {
            const obj = JSON.parse(json);
            if (obj && typeof obj === 'object') {
                this.save(obj);
                return true;
            }
        } catch(e) {
            console.error('Import failed:', e);
        }
        return false;
    }
};

function defaultSave() {
    return {
        settings: { 
            musicVol: 0.4, 
            sfxVol: 0.9, 
            difficulty: 'normal', 
            showTouch: true 
        },
        stats: { 
            best: 0, 
            leaderboard: [] 
        },
        progress: { 
            unlockedStages: 1 
        }
    };
}

function uid(prefix = 'id') {
    return prefix + '_' + Math.random().toString(36).slice(2, 9);
}

const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

/* AUDIO MANAGER */
class AudioManager {
    constructor() {
        this.ctx = null;
        this.masterGain = null;
        this.musicGain = null;
        this.sfxGain = null;
        this.isPlaying = false;
        this.musicNode = null;
        this.initialized = false;
    }
    
    async init() {
        if (this.initialized) return true;
        
        try {
            const C = window.AudioContext || window.webkitAudioContext;
            if (!C) {
                console.warn('Web Audio API not supported');
                return false;
            }
            
            this.ctx = new C();
            
            // Create audio graph
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.9;
            this.masterGain.connect(this.ctx.destination);
            
            this.musicGain = this.ctx.createGain();
            this.musicGain.gain.value = 0.4;
            this.musicGain.connect(this.masterGain);
            
            this.sfxGain = this.ctx.createGain();
            this.sfxGain.gain.value = 0.9;
            this.sfxGain.connect(this.masterGain);
            
            this._startAmbient();
            this.initialized = true;
            console.log('‚úÖ AudioManager initialized successfully');
            return true;
        } catch(error) {
            console.error('‚ùå AudioManager init error:', error);
            this.ctx = null;
            return false;
        }
    }
    
    _startAmbient() {
        if (!this.ctx) return;
        
        try {
            const o = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            const lpf = this.ctx.createBiquadFilter();
            
            lpf.type = 'lowpass';
            lpf.frequency.value = 800;
            o.type = 'sine';
            o.frequency.value = 55;
            g.gain.value = 0.0;
            
            o.connect(lpf);
            lpf.connect(g);
            g.connect(this.musicGain);
            o.start();
            
            // Add subtle modulation
            const lfo = this.ctx.createOscillator();
            const lfoGain = this.ctx.createGain();
            lfo.frequency.value = 0.08;
            lfo.type = 'sine';
            lfoGain.gain.value = 0.3;
            lfo.connect(lfoGain);
            lfoGain.connect(g.gain);
            lfo.start();
            
            // Fade in
            g.gain.linearRampToValueAtTime(0.06, this.ctx.currentTime + 0.8);
            
            this.musicNode = { o, g, lfo, lfoGain, lpf };
            this.isPlaying = true;
        } catch(e) {
            console.warn('Ambient audio setup failed:', e);
        }
    }
    
    setMusicVolume(v) {
        if (this.musicGain) {
            this.musicGain.gain.value = v;
        }
    }
    
    setSfxVolume(v) {
        if (this.sfxGain) {
            this.sfxGain.gain.value = v;
        }
    }
    
    resumeIfNeeded() {
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }
    
    sfx(type = 'beep') {
        if (!this.ctx) return;
        
        try {
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            
            filter.type = 'highpass';
            filter.frequency.value = 120;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.sfxGain);
            
            switch(type) {
                case 'collect':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(900, t);
                    gain.gain.value = 0.0001;
                    gain.gain.exponentialRampToValueAtTime(0.18, t + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.28);
                    break;
                case 'hit':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(150, t);
                    gain.gain.value = 0.15;
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
                    break;
                case 'dash':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(600, t);
                    gain.gain.value = 0.18;
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
                    break;
                default:
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, t);
                    gain.gain.value = 0.12;
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
            }
            
            osc.start(t);
            osc.stop(t + 0.5);
        } catch(e) {
            console.warn('SFX failed:', e);
        }
    }
    
    stopAll() {
        if (!this.ctx) return;
        
        try {
            if (this.musicNode) {
                if (this.musicNode.o) this.musicNode.o.stop();
                if (this.musicNode.lfo) this.musicNode.lfo.stop();
            }
            this.isPlaying = false;
        } catch(e) {
            console.warn('Stop all audio failed:', e);
        }
    }
}

// Initialize core components
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let DPR = Math.max(window.devicePixelRatio || 1, 1);

// UI Elements
const UI = {
    score: document.getElementById('score'),
    stage: document.getElementById('stage'),
    health: document.getElementById('health'),
    best: document.getElementById('best'),
    sideScore: document.getElementById('sideScore'),
    sideBest: document.getElementById('sideBest'),
    overlayMenu: document.getElementById('overlayMenu'),
    startBtn: document.getElementById('startBtn'),
    continueBtn: document.getElementById('continueBtn'),
    settingsBtn: document.getElementById('settingsBtn'),
    leaderBtn: document.getElementById('leaderBtn'),
    pauseBtn: document.getElementById('pauseBtn'),
    muteBtn: document.getElementById('muteBtn'),
    themeBtn: document.getElementById('themeBtn'),
    leaderList: document.getElementById('leaderList'),
    exportSave: document.getElementById('exportSave'),
    importFile: document.getElementById('importFile'),
    retryBtn: document.getElementById('retryBtn'),
    menuBtn: document.getElementById('menuBtn'),
    gameOverModal: document.getElementById('gameOverModal'),
    finalScore: document.getElementById('finalScore'),
    cdDash: document.getElementById('cd-dash'),
    cdShield: document.getElementById('cd-shield'),
    abilityDash: document.getElementById('ability-dash'),
    abilityShield: document.getElementById('ability-shield'),
    mobileMenuBtn: document.getElementById('mobileMenuBtn'),
    sidebar: document.getElementById('sidebar'),
    gameWrap: document.getElementById('gameWrap')
};

// Settings UI
const SETTINGS_UI = {
    musicVol: document.getElementById('musicVol'),
    sfxVol: document.getElementById('sfxVol'),
    difficulty: document.getElementById('difficulty'),
    showTouch: document.getElementById('showTouch'),
    touchControls: document.getElementById('touchControls'),
    btnLeft: document.getElementById('btn-left'),
    btnRight: document.getElementById('btn-right'),
    btnJump: document.getElementById('btn-jump')
};

// Load saved data
const SAVE = Storage.load() || defaultSave();
const audio = new AudioManager();
let settings = SAVE.settings;
let stats = SAVE.stats;

/* PARTICLE SYSTEM */
class Particle {
    constructor(x, y, dx, dy, color, life, alpha = 1) {
        this.x = x;
        this.y = y;
        this.dx = dx;
        this.dy = dy;
        this.color = color;
        this.life = life;
        this.max = life;
        this.alpha = alpha;
    }
    
    update(dt) {
        this.x += this.dx * dt;
        this.y += this.dy * dt;
        this.life -= dt;
    }
    
    draw(ctx) {
        const r = Math.max(1, (this.life / this.max) * 3);
        ctx.save();
        ctx.globalAlpha = clamp(this.life / this.max, 0, 1) * this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class ParticleSystem {
    constructor() {
        this.particles = [];
    }
    
    spawn(x, y, amount = 12, spread = 40, color = '#00fff0') {
        for (let i = 0; i < amount; i++) {
            const ang = Math.random() * Math.PI * 2;
            const sp = 20 + Math.random() * 80;
            const dx = Math.cos(ang) * sp;
            const dy = Math.sin(ang) * sp;
            const life = 0.4 + Math.random() * 0.7;
            this.particles.push(new Particle(x, y, dx, dy, color, life, 0.9));
        }
    }
    
    update(dt) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.update(dt);
            if (p.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
    }
    
    draw(ctx) {
        for (const p of this.particles) {
            p.draw(ctx);
        }
    }
}

/* PLAYER CLASS */
class Player {
    constructor(game) {
        this.game = game;
        this.x = 140;
        this.lane = 1;
        this.targetLane = 1;
        this.y = 0;
        this.radius = 24;
        this.color = '#00fff0';
        this.health = 3;
        this.invulnerable = 0;
        this.dashCooldown = 0;
        this.shieldCooldown = 0;
        this.shieldActive = 0;
        this.scoreMultiplier = 1;
        this._yAnim = 0;
    }
    
    respawn() {
        this.health = 3;
        this.invulnerable = 0;
        this.dashCooldown = 0;
        this.shieldCooldown = 0;
        this.shieldActive = 0;
        this.lane = 1;
        this.targetLane = 1;
        this._yAnim = 0;
    }
    
    update(dt) {
        // Smooth lane transition
        this.targetLane = clamp(this.targetLane, 0, 2);
        const targetY = this.game.lanePositions[this.targetLane];
        
        // Animate Y position
        this._yAnim += (targetY - this._yAnim) * clamp(12 * dt, 0, 1);
        this.y = this._yAnim;
        
        // Update cooldowns
        if (this.invulnerable > 0) this.invulnerable -= dt;
        if (this.dashCooldown > 0) this.dashCooldown -= dt;
        if (this.shieldCooldown > 0) this.shieldCooldown -= dt;
        if (this.shieldActive > 0) this.shieldActive -= dt;
    }
    
    draw(ctx) {
        ctx.save();
        
        // Glow effect
        const pulse = 0.6 + Math.sin(Date.now() * 0.002) * 0.2;
        ctx.shadowBlur = 28;
        ctx.shadowColor = this.shieldActive > 0 ? 'rgba(255,178,77,0.55)' : 'rgba(0,255,240,0.65)';
        
        // Body
        ctx.fillStyle = this.shieldActive > 0 ? 'rgba(255,178,77,0.95)' : 'rgba(0,255,240,0.98)';
        this._roundRect(ctx, this.x - 28, this.y - 28, 56, 56, 12);
        ctx.fill();
        
        // Inner core
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#071417';
        this._roundRect(ctx, this.x - 16, this.y - 12, 32, 24, 8);
        ctx.fill();
        
        ctx.restore();
        
        // Invulnerability flash
        if (this.invulnerable > 0) {
            ctx.save();
            ctx.globalAlpha = 0.25 + Math.abs(Math.sin(Date.now() * 0.02)) * 0.15;
            ctx.fillStyle = '#ffffff';
            this._roundRect(ctx, this.x - 28, this.y - 28, 56, 56, 12);
            ctx.fill();
            ctx.restore();
        }
    }
    
    _roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    }
    
    moveUp() {
        this.targetLane = clamp(this.targetLane - 1, 0, 2);
    }
    
    moveDown() {
        this.targetLane = clamp(this.targetLane + 1, 0, 2);
    }
    
    tryDash() {
        if (this.dashCooldown <= 0) {
            this.dashCooldown = 2.2;
            this.invulnerable = 0.22;
            return true;
        }
        return false;
    }
    
    tryShield() {
        if (this.shieldCooldown <= 0) {
            this.shieldCooldown = 8.0;
            this.shieldActive = 2.0;
            return true;
        }
        return false;
    }
}

/* OBSTACLE CLASS */
class Obstacle {
    constructor(game, lane, speed, kind = 'barrier') {
        this.game = game;
        this.lane = lane;
        this.x = game.width + 90 + Math.random() * 80;
        this.width = 54 + Math.random() * 40;
        this.height = 34 + Math.random() * 60;
        this.speed = speed;
        this.kind = kind;
        this.color = (kind === 'laser') ? '#ff4dd2' : '#ffb24d';
        this.hit = false;
        this.id = uid('obs');
    }
    
    update(dt) {
        this.x -= this.speed * dt;
    }
    
    draw(ctx) {
        const y = this.game.lanePositions[this.lane];
        ctx.save();
        ctx.translate(this.x, y);
        
        // Shadow/glow
        ctx.shadowBlur = 26;
        ctx.shadowColor = this.kind === 'laser' ? 'rgba(255,77,210,0.8)' : 'rgba(255,178,77,0.6)';
        
        // Main shape
        ctx.fillStyle = this.kind === 'laser' ? '#311029' : '#2b1608';
        this._roundRect(ctx, -this.width / 2, -this.height / 2, this.width, this.height, 8);
        ctx.fill();
        
        // Inner glow
        ctx.shadowBlur = 0;
        ctx.fillStyle = this.color;
        this._roundRect(ctx, -this.width / 2 + 6, -8, this.width - 12, 16, 6);
        ctx.fill();
        
        ctx.restore();
    }
    
    _roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    }
    
    collidesWith(player) {
        const cy = this.game.lanePositions[this.lane];
        const px = player.x, py = player.y;
        const w = this.width, h = this.height;
        const left = this.x - w / 2, right = this.x + w / 2;
        const top = cy - h / 2, bottom = cy + h / 2;
        
        const closestX = clamp(px, left, right);
        const closestY = clamp(py, top, bottom);
        const dx = px - closestX, dy = py - closestY;
        const dist2 = dx * dx + dy * dy;
        
        return dist2 < (player.radius * player.radius);
    }
}

/* SHARD CLASS */
class Shard {
    constructor(game, lane, speed) {
        this.game = game;
        this.lane = lane;
        this.x = game.width + 60 + Math.random() * 120;
        this.radius = 12;
        this.speed = speed;
        this.collected = false;
        this.color = '#00fff0';
        this.id = uid('shd');
    }
    
    update(dt) {
        this.x -= this.speed * dt;
    }
    
    draw(ctx) {
        const y = this.game.lanePositions[this.lane];
        ctx.save();
        ctx.translate(this.x, y);
        
        ctx.shadowColor = 'rgba(0,255,240,0.85)';
        ctx.shadowBlur = 18;
        ctx.fillStyle = 'rgba(0,255,240,0.96)';
        this._star(ctx, 0, 0, 5, this.radius, this.radius * 0.5);
        ctx.fill();
        
        ctx.restore();
    }
    
    _star(ctx, x, y, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let step = Math.PI / spikes;
        
        ctx.beginPath();
        ctx.moveTo(x, y - outerRadius);
        
        for (let i = 0; i < spikes; i++) {
            let ox = x + Math.cos(rot) * outerRadius;
            let oy = y + Math.sin(rot) * outerRadius;
            ctx.lineTo(ox, oy);
            rot += step;

            ox = x + Math.cos(rot) * innerRadius;
            oy = y + Math.sin(rot) * innerRadius;
            ctx.lineTo(ox, oy);
            rot += step;
        }
        
        ctx.lineTo(x, y - outerRadius);
        ctx.closePath();
    }
    
    collidesWith(player) {
        const cy = this.game.lanePositions[this.lane];
        const dx = player.x - this.x;
        const dy = player.y - cy;
        return (dx * dx + dy * dy) < Math.pow(this.radius + player.radius * 0.45, 2);
    }
}

/* MAIN GAME CLASS */
class Game {
    constructor() {
        this.canvas = canvas;
        this.ctx = ctx;
        this.width = 800;
        this.height = 600;
        this.running = false;
        this.paused = false;
        this.particles = new ParticleSystem();
        this.player = new Player(this);
        this.obstacles = [];
        this.shards = [];
        this.spawnTimer = 0;
        this.shardTimer = 0;
        this.speed = 360;
        this.baseSpeed = 360;
        this.stage = 1;
        this.score = 0;
        this.best = stats.best || 0;
        this.spawnInterval = 1.2;
        this.shardInterval = 1.0;
        this.lanePositions = [0, 0, 0];
        this.lastTime = 0;
        this.accumulator = 0;
        this.frameId = null;
        this.touchState = { left: false, right: false, jump: false };
        this.difficulty = settings.difficulty || 'normal';
        
        this.initCanvas();
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        console.log('‚úÖ Game instance created');
    }
    
    initCanvas() {
        this.resize();
    }
    
    resize() {
        DPR = Math.max(window.devicePixelRatio || 1, 1);
        const rect = this.canvas.getBoundingClientRect();
        
        this.width = Math.max(320, Math.min(rect.width, window.innerWidth));
        this.height = Math.max(400, rect.height || 500);
        
        this.canvas.width = Math.floor(this.width * DPR);
        this.canvas.height = Math.floor(this.height * DPR);
        this.canvas.style.width = this.width + 'px';
        this.canvas.style.height = this.height + 'px';
        
        this.ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        
        // Update lane positions
        const laneGap = Math.max(70, this.height / 5);
        const center = this.height * 0.5;
        this.lanePositions = [center - laneGap, center, center + laneGap];
        
        // Update player position
        this.player._yAnim = this.lanePositions[this.player.lane];
        this.player.y = this.player._yAnim;
    }
    
    init() {
        this.speed = (this.difficulty === 'easy') ? 280 : (this.difficulty === 'hard') ? 420 : 360;
        this.baseSpeed = this.speed;
        this.player.respawn();
        this.obstacles = [];
        this.shards = [];
        this.particles = new ParticleSystem();
        this.spawnTimer = 0;
        this.shardTimer = 0;
        this.score = 0;
        this.stage = 1;
        this.paused = false;
        
        updateUI();
        console.log('‚úÖ Game initialized');
    }
    
    start() {
        if (this.running) return;
        
        this.running = true;
        this.lastTime = performance.now();
        this.frameId = requestAnimationFrame((t) => this.loop(t));
        console.log('üéÆ Game started');
    }
    
    stop() {
        this.running = false;
        if (this.frameId) {
            cancelAnimationFrame(this.frameId);
            this.frameId = null;
        }
        console.log('üõë Game stopped');
    }
    
    loop(ts) {
        if (!this.running) return;
        
        const now = ts;
        let dt = (now - this.lastTime) / 1000;
        dt = Math.min(dt, 0.05);
        this.lastTime = now;
        
        if (!this.paused) {
            this.update(dt);
            this.draw();
        } else {
            this.draw();
            this.drawPauseOverlay();
        }
        
        this.frameId = requestAnimationFrame((t) => this.loop(t));
    }
    
    update(dt) {
        // Spawn obstacles
        this.spawnTimer -= dt;
        if (this.spawnTimer <= 0) {
            this.spawnObstacle();
            this.spawnTimer = clamp(this.spawnInterval - Math.log1p(this.score) * 0.02, 0.6, 1.5);
        }
        
        // Spawn shards
        this.shardTimer -= dt;
        if (this.shardTimer <= 0) {
            if (Math.random() < 0.7) this.spawnShard();
            this.shardTimer = clamp(this.shardInterval - Math.log1p(this.score) * 0.01, 0.5, 1.4);
        }
        
        // Update player
        this.player.update(dt);
        
        // Update obstacles
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            const o = this.obstacles[i];
            o.update(dt * (1 + Math.log1p(this.stage) * 0.06));
            
            if (o.x < -120) {
                this.obstacles.splice(i, 1);
            } else if (!o.hit && o.collidesWith(this.player)) {
                if (this.player.invulnerable <= 0 && this.player.shieldActive <= 0) {
                    // Hit player
                    this.player.health -= 1;
                    this.player.invulnerable = 0.9;
                    o.hit = true;
                    audio.sfx('hit');
                    this.particles.spawn(o.x, this.lanePositions[o.lane], 18, 40, '#ff4d6e');
                    
                    if (this.player.health <= 0) {
                        this.gameOver();
                    }
                    
                    updateUI();
                } else {
                    // Shield or invulnerable - just spark
                    this.particles.spawn(o.x, this.lanePositions[o.lane], 8, 30, '#ffd07a');
                    o.hit = true;
                }
            }
        }
        
        // Update shards
        for (let i = this.shards.length - 1; i >= 0; i--) {
            const s = this.shards[i];
            s.update(dt);
            
            if (s.x < -80) {
                this.shards.splice(i, 1);
            } else if (!s.collected && s.collidesWith(this.player)) {
                s.collected = true;
                stats.best = Math.max(stats.best, this.score + 10);
                this.score += 10;
                audio.sfx('collect');
                this.particles.spawn(s.x, this.lanePositions[s.lane], 12, 26, '#00fff0');
                this.shards.splice(i, 1);
                updateUI();
            }
        }
        
        // Update particles
        this.particles.update(dt);
        
        // Increment score
        this.score += dt * (12 + this.stage * 2);
        
        // Stage progression
        const oldStage = this.stage;
        this.stage = 1 + Math.floor(this.score / 500);
        if (this.stage !== oldStage) {
            audio.sfx('beep');
            this.particles.spawn(this.player.x + 40, this.player.y, 30, 120, '#ffb24d');
            this.speed = this.baseSpeed + this.stage * 20;
            updateUI();
        }
        
        // Auto-save
        this.accumulator += dt;
        if (this.accumulator > 3) {
            this.save();
            this.accumulator = 0;
        }
    }
    
    spawnObstacle() {
        const lane = Math.floor(Math.random() * 3);
        const kindRand = Math.random();
        let kind = 'barrier';
        
        if (kindRand > 0.87) kind = 'drone';
        else if (kindRand > 0.6) kind = 'laser';
        
        const obs = new Obstacle(this, lane, this.speed * (0.9 + Math.random() * 0.4), kind);
        this.obstacles.push(obs);
    }
    
    spawnShard() {
        const lane = Math.floor(Math.random() * 3);
        const sh = new Shard(this, lane, this.speed * (0.85 + Math.random() * 0.25));
        this.shards.push(sh);
    }
    
    draw() {
        const ctx = this.ctx;
        
        // Clear canvas
        ctx.fillStyle = '#060709';
        ctx.fillRect(0, 0, this.width, this.height);
        
        // Draw components
        this.drawBackground(ctx);
        this.drawTrack(ctx);
        
        // Draw entities
        for (const s of this.shards) s.draw(ctx);
        for (const o of this.obstacles) o.draw(ctx);
        this.player.draw(ctx);
        this.particles.draw(ctx);
        
        this.drawHUDDecor(ctx);
    }
    
    drawBackground(ctx) {
        // Gradient background
        const g = ctx.createLinearGradient(0, 0, 0, this.height);
        g.addColorStop(0, '#05060a');
        g.addColorStop(1, '#071018');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, this.width, this.height);
        
        // Animated neon bands
        const t = (Date.now() % 10000) / 10000;
        for (let i = 0; i < 4; i++) {
            ctx.save();
            const alpha = 0.04 + i * 0.02;
            ctx.fillStyle = rgba(0,255,240,${0.02 + (i * 0.01)});
            const y = (this.height * (0.1 + i * 0.25)) + Math.sin(Date.now() * 0.002 + i) * 22;
            ctx.globalAlpha = alpha;
            ctx.fillRect(0, y, this.width, 8);
            ctx.restore();
        }
        
        // Vignette
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        const rad = ctx.createRadialGradient(
            this.width * 0.1, this.height * 0.2, 10,
            this.width / 2, this.height / 2, Math.max(this.width, this.height)
        );
        rad.addColorStop(0, 'rgba(255,255,255,0.03)');
        rad.addColorStop(0.4, 'rgba(0,0,0,0.0)');
        rad.addColorStop(1, 'rgba(0,0,0,0.7)');
        ctx.fillStyle = rad;
        ctx.fillRect(0, 0, this.width, this.height);
        ctx.restore();
    }
    
    drawTrack(ctx) {
        ctx.save();
        
        // Rail lines
        for (let i = 0; i < 3; i++) {
            const y = this.lanePositions[i];
            ctx.beginPath();
            ctx.moveTo(0, y + 40);
            ctx.lineTo(this.width, y + 40);
            ctx.lineWidth = 1.4;
            ctx.strokeStyle = (i === 1) ? 'rgba(0,255,240,0.05)' : 'rgba(255,77,210,0.03)';
            ctx.stroke();
            
            // Moving segments
            ctx.lineWidth = 2;
            const step = 140;
            const offset = (Date.now() * 0.03) % step;
            for (let x = -100; x < this.width + 200; x += step) {
                ctx.globalAlpha = 0.16;
                this._roundRect(ctx, x + offset, y + 10, 60, 8, 4);
                ctx.fillStyle = 'rgba(255,255,255,0.02)';
                ctx.fill();
            }
        }
        
        ctx.restore();
    }
    
    _roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    }
    
    drawHUDDecor(ctx) {
        ctx.save();
        ctx.globalAlpha = 0.08;
        ctx.strokeStyle = 'rgba(0,255,240,0.06)';
        for (let x = 0; x < this.width; x += 120) {
            ctx.beginPath();
            ctx.moveTo(x + ((Date.now() * 0.03) % 120), 0);
            ctx.lineTo(x + ((Date.now() * 0.03) % 120), this.height);
            ctx.stroke();
        }
        ctx.restore();
    }
    
    drawPauseOverlay() {
        const ctx = this.ctx;
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, this.width, this.height);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 24px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', this.width / 2, this.height / 2);
        
        ctx.restore();
    }
    
    pause() {
        this.paused = true;
    }
    
    resume() {
        this.paused = false;
    }
    
    togglePause() {
        this.paused = !this.paused;
        UI.pauseBtn.textContent = this.paused ? 'ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ' : 'ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™';
    }
    
    gameOver() {
        this.running = false;
        this.player.health = 0;
        
        const final = Math.floor(this.score);
        stats.best = Math.max(stats.best || 0, final);
        
        // Update leaderboard
        const lb = stats.leaderboard || [];
        lb.push({ score: final, when: new Date().toISOString() });
        lb.sort((a, b) => b.score - a.score);
        if (lb.length > 10) lb.length = 10;
        stats.leaderboard = lb;
        
        this.save(true);
        
        // Show game over modal
        UI.finalScore.textContent = final;
        UI.gameOverModal.style.display = 'flex';
        UI.overlayMenu.style.display = 'none';
        
        refreshLeaderboard();
        cancelAnimationFrame(this.frameId);
        
        console.log('üíÄ Game Over - Score:', final);
    }
    
    save(force = false) {
        const obj = Storage.load() || defaultSave();
        obj.settings = settings;
        obj.stats = stats;
        obj.progress = { unlockedStages: Math.max(obj.progress?.unlockedStages || 1, this.stage) };
        Storage.save(obj);
        updateUI();
    }
}

// Initialize game
const game = new Game();

/* INPUT HANDLING */
const keys = {};

// Keyboard events
window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    keys[e.key.toLowerCase()] = true;
    handleKeyDown(e.key.toLowerCase());
});

window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

function handleKeyDown(k) {
    if (k === 'arrowup' || k === 'w' || k === 'w') {
        game.player.moveUp();
    }
    if (k === 'arrowdown' || k === 's' || k === 's') {
        game.player.moveDown();
    }
    if (k === 'f') {
        if (game.player.tryDash()) audio.sfx('dash');
    }
    if (k === 'g') {
        if (game.player.tryShield()) audio.sfx('beep');
    }
    if (k === 'p' || k === ' ') {
        game.togglePause();
    }
}

// Touch controls
SETTINGS_UI.btnLeft.addEventListener('touchstart', (e) => {
    e.preventDefault();
    game.player.moveUp();
});

SETTINGS_UI.btnRight.addEventListener('touchstart', (e) => {
    e.preventDefault();
    game.player.moveDown();
});

SETTINGS_UI.btnJump.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (game.player.tryDash()) audio.sfx('dash');
});

// Mobile menu toggle
UI.mobileMenuBtn.addEventListener('click', () => {
    UI.sidebar.classList.toggle('mobile-visible');
    UI.gameWrap.classList.toggle('sidebar-visible');
    UI.mobileMenuBtn.textContent = UI.sidebar.classList.contains('mobile-visible') ? '‚úï' : '‚ò∞';
});

/* UI EVENT HANDLERS */
UI.startBtn.addEventListener('click', async () => {
    try {
        await audio.init();
        audio.resumeIfNeeded();
        openGameFromMenu();
    } catch (error) {
        console.error('Start failed:', error);
        openGameFromMenu(); // Continue without audio
    }
});

UI.retryBtn.addEventListener('click', () => {
    UI.gameOverModal.style.display = 'none';
    UI.overlayMenu.style.display = 'none';
    game.init();
    game.start();
});

UI.menuBtn.addEventListener('click', () => {
    UI.gameOverModal.style.display = 'none';
    UI.overlayMenu.style.display = 'flex';
});

UI.pauseBtn.addEventListener('click', () => {
    game.togglePause();
});

UI.muteBtn.addEventListener('click', () => {
    if (audio.ctx && audio.musicGain) {
        if (audio.musicGain.gain.value > 0.001) {
            audio.setMusicVolume(0);
            UI.muteBtn.textContent = 'ÿµŸàÿ™';
        } else {
            audio.setMusicVolume(settings.musicVol);
            UI.muteBtn.textContent = 'ŸÉÿ™ŸÖ';
        }
    }
});

UI.settingsBtn.addEventListener('click', () => {
    alert('ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ŸÅŸä ÿßŸÑÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ¨ÿßŸÜÿ®Ÿä: ÿßÿ∂ÿ®ÿ∑ ÿßŸÑÿµŸàÿ™ Ÿàÿ∑ÿ±ŸÇ ÿßŸÑÿ™ÿ≠ŸÉŸÖ.');
});

UI.leaderBtn.addEventListener('click', () => {
    refreshLeaderboard();
    alert('ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ£ŸÅÿ∂ŸÑ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´Ÿáÿß ŸÅŸä ÿßŸÑÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ¨ÿßŸÜÿ®Ÿä.');
});

UI.exportSave.addEventListener('click', () => {
    Storage.exportJSON('echo-backup.json');
});

UI.importFile.addEventListener('change', (ev) => {
    const f = ev.target.files[0];
    if (!f) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
        if (Storage.importJSON(e.target.result)) {
            location.reload();
        } else {
            alert('ŸÖŸÑŸÅ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
        }
    };
    reader.readAsText(f);
});

UI.abilityDash.addEventListener('click', () => {
    if (game.player.tryDash()) audio.sfx('dash');
});

UI.abilityShield.addEventListener('click', () => {
    if (game.player.tryShield()) audio.sfx('beep');
});

UI.continueBtn.addEventListener('click', () => {
    UI.overlayMenu.style.display = 'none';
    game.start();
});

// Settings handlers
SETTINGS_UI.musicVol.addEventListener('input', (e) => {
    settings.musicVol = +e.target.value;
    audio.setMusicVolume(settings.musicVol);
    saveAll();
});

SETTINGS_UI.sfxVol.addEventListener('input', (e) => {
    settings.sfxVol = +e.target.value;
    audio.setSfxVolume(settings.sfxVol);
    saveAll();
});

SETTINGS_UI.difficulty.addEventListener('change', (e) => {
    settings.difficulty = e.target.value;
    saveAll();
});

SETTINGS_UI.showTouch.addEventListener('change', (e) => {
    settings.showTouch = e.target.checked;
    SETTINGS_UI.touchControls.style.display = e.target.checked ? 'flex' : 'none';
    saveAll();
});

/* GAME FUNCTIONS */
function openGameFromMenu() {
    UI.overlayMenu.style.display = 'none';
    audio.setMusicVolume(settings.musicVol);
    audio.setSfxVolume(settings.sfxVol);
    game.difficulty = settings.difficulty;
    game.init();
    game.start();
    
    // Show touch controls on mobile
    if (settings.showTouch && window.innerWidth < 768) {
        SETTINGS_UI.touchControls.style.display = 'flex';
    } else {
        SETTINGS_UI.touchControls.style.display = 'none';
    }
}

function updateUI() {
    UI.score.textContent = Math.floor(game.score);
    UI.sideScore.textContent = Math.floor(game.score);
    UI.stage.textContent = game.stage;
    UI.health.textContent = game.player.health;
    UI.best.textContent = stats.best || 0;
    UI.sideBest.textContent = stats.best || 0;
}

function updateCooldownUI(cdDash, cdShield, player) {
    const dashMax = 2.2, shieldMax = 8.0;
    const dashRatio = clamp(cdDash / dashMax, 0, 1);
    const shieldRatio = clamp(cdShield / shieldMax, 0, 1);
    
    UI.cdDash.style.transform = scaleY(${dashRatio});
    UI.cdShield.style.transform = scaleY(${shieldRatio});
}

function refreshLeaderboard() {
    const lb = stats.leaderboard || [];
    UI.leaderList.innerHTML = '';
    
    if (lb.length === 0) {
        const li = document.createElement('li');
        li.className = 'muted';
        li.textContent = 'ŸÑÿß ÿ≥ÿ¨ŸÑÿßÿ™ ÿ≠ÿ™Ÿâ ÿßŸÑÿ¢ŸÜ';
        UI.leaderList.appendChild(li);
        return;
    }
    
    for (const item of lb) {
        const li = document.createElement('li');
        li.innerHTML = <span>${new Date(item.when).toLocaleDateString()}</span><strong>${item.score}</strong>;
        UI.leaderList.appendChild(li);
    }
}

function saveAll() {
    SAVE.settings = settings;
    SAVE.stats = stats;
    Storage.save(SAVE);
}

/* INITIALIZATION */
(function initUI() {
    // Load settings
    SETTINGS_UI.musicVol.value = settings.musicVol ?? 0.4;
    SETTINGS_UI.sfxVol.value = settings.sfxVol ?? 0.9;
    SETTINGS_UI.difficulty.value = settings.difficulty ?? 'normal';
    SETTINGS_UI.showTouch.checked = settings.showTouch ?? true;
    
    // Show touch controls on mobile by default
    if (window.innerWidth < 768 && settings.showTouch) {
        SETTINGS_UI.touchControls.style.display = 'flex';
    } else {
        SETTINGS_UI.touchControls.style.display = 'none';
    }
    
    // Initialize best scores
    document.getElementById('best').textContent = stats.best || 0;
    document.getElementById('sideBest').textContent = stats.best || 0;
    
    refreshLeaderboard();
    
    console.log('‚úÖ UI initialized');
})();

// Auto-save on unload
window.addEventListener('beforeunload', () => {
    game.save(true);
});

// Initialize audio on first interaction
document.addEventListener('click', async function onFirst() {
    document.removeEventListener('click', onFirst);
    try {
        await audio.init();
        audio.setMusicVolume(settings.musicVol);
        audio.setSfxVolume(settings.sfxVol);
    } catch (e) {
        console.warn('Audio init on click failed:', e);
    }
}, { once: true });

console.log('üéâ ECHO RUNNER - Ready! Click Start to play.');

// Expose for debugging
window.__ECHO = { game, audio, settings, stats, Storage };
</script>
</body>
</html>
